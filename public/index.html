<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- 캡처 방지 메타 태그 -->
  <meta name="robots" content="noindex, nofollow">
  <meta name="googlebot" content="noindex, nofollow">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><defs><linearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'><stop offset='0%25' style='stop-color:%23667eea'/><stop offset='100%25' style='stop-color:%23764ba2'/></linearGradient></defs><circle cx='50' cy='50' r='45' fill='url(%23g)'/><path d='M50 25 L35 35 L35 50 Q35 65 50 70 Q65 65 65 50 L65 35 Z' fill='white'/><circle cx='50' cy='52' r='5' fill='url(%23g)'/><rect x='48' y='55' width='4' height='8' fill='url(%23g)'/></svg>">
  <link rel="stylesheet" href="style.css">
  <style>
    /* 캡처 방지 스타일 */
    * {
      -webkit-user-select: none !important;
      -moz-user-select: none !important;
      -ms-user-select: none !important;
      user-select: none !important;
      -webkit-touch-callout: none !important;
      -webkit-tap-highlight-color: transparent !important;
    }
    
    body {
      -webkit-user-select: none !important;
      -moz-user-select: none !important;
      -ms-user-select: none !important;
      user-select: none !important;
      -webkit-touch-callout: none !important;
      -webkit-tap-highlight-color: transparent !important;
    }
    
    .chat-container {
      -webkit-user-select: none !important;
      -moz-user-select: none !important;
      -ms-user-select: none !important;
      user-select: none !important;
      -webkit-touch-callout: none !important;
      -webkit-tap-highlight-color: transparent !important;
    }
    
    .message-bubble {
      -webkit-user-select: none !important;
      -moz-user-select: none !important;
      -ms-user-select: none !important;
      user-select: none !important;
      -webkit-touch-callout: none !important;
      -webkit-tap-highlight-color: transparent !important;
    }
    
    /* 입력 필드는 선택 허용 */
    input, textarea {
      -webkit-user-select: text !important;
      -moz-user-select: text !important;
      -ms-user-select: text !important;
      user-select: text !important;
    }
    
    /* 비밀번호 모달 스타일 */
    #passwordModal, #passwordSetupModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .password-box {
      background: white;
      padding: 33px;
      border-radius: 17px;
      box-shadow: 0 7px 33px rgba(0,0,0,0.4);
      max-width: 333px;
      width: 95%;
      text-align: center;
    }

    .password-icon {
      text-align: center;
      font-size: 43px;
      margin-bottom: 17px;
    }

    .password-title {
      font-size: 19px;
      font-weight: bold;
      color: #333;
      margin-bottom: 13px;
    }

    .password-description {
      font-size: 12px;
      color: #666;
      margin-bottom: 23px;
      line-height: 1.6;
    }

    #passwordInput, #newPasswordInput, #confirmPasswordInput {
      width: 100%;
      padding: 17px;
      font-size: 19px;
      border: 3px solid #007aff;
      border-radius: 10px;
      text-align: center;
      box-sizing: border-box;
      margin-bottom: 13px;
      font-weight: bold;
      letter-spacing: 2px;
    }

    #passwordInput:focus, #newPasswordInput:focus, #confirmPasswordInput:focus {
      outline: none;
      border-color: #0051d5;
      box-shadow: 0 0 0 4px rgba(0, 122, 255, 0.15);
    }

    .password-buttons {
      display: flex;
      gap: 13px;
      margin-top: 17px;
    }

    #decryptButton, #setPasswordButton {
      flex: 1;
      padding: 15px 20px;
      background: #007aff;
      color: white;
      border: none;
      border-radius: 10px;
      font-size: 13px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s ease;
    }

    #decryptButton:hover, #setPasswordButton:hover {
      background: #0051d5;
      transform: translateY(-2px);
      box-shadow: 0 4px 13px rgba(0, 122, 255, 0.4);
    }

    #cancelButton, #cancelSetupButton {
      padding: 15px 20px;
      background: #f0f0f0;
      color: #666;
      border: none;
      border-radius: 10px;
      font-size: 13px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s ease;
    }

    #cancelButton:hover, #cancelSetupButton:hover {
      background: #e0e0e0;
      transform: translateY(-2px);
    }

    /* 모바일 대응 */
    @media (max-width: 768px) {
      .password-box {
        padding: 27px 20px;
        max-width: 90%;
      }
      
      .password-icon {
        font-size: 37px;
      }
      
      .password-title {
        font-size: 16px;
      }
      
      .password-description {
        font-size: 11px;
      }
      
      #passwordInput, #newPasswordInput, #confirmPasswordInput {
        padding: 13px;
        font-size: 16px;
      }
      
      .password-buttons {
        flex-direction: column;
        gap: 10px;
      }
      
      #decryptButton, #setPasswordButton, #cancelButton, #cancelSetupButton {
        padding: 12px 17px;
        font-size: 12px;
      }
    }
  </style>
  <title>KyberChat - 양자 안전 채팅</title>
</head>
<body>
  <!-- 사용자 이름 입력 모달 -->
  <div id="usernameModal" class="modal">
    <div class="modal-content">
      <div style="text-align: center; margin-bottom: 20px;">
        <svg width="80" height="80" viewBox="0 0 100 100" style="margin-bottom: 10px;">
          <defs>
            <linearGradient id="logoGrad" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" style="stop-color:#667eea"/>
              <stop offset="100%" style="stop-color:#764ba2"/>
            </linearGradient>
          </defs>
          <circle cx="50" cy="50" r="45" fill="url(#logoGrad)"/>
          <path d="M50 25 L35 35 L35 50 Q35 65 50 70 Q65 65 65 50 L65 35 Z" fill="white"/>
          <circle cx="50" cy="52" r="5" fill="url(#logoGrad)"/>
          <rect x="48" y="55" width="4" height="8" fill="url(#logoGrad)"/>
        </svg>
        <h2 style="margin: 0; font-size: 32px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; font-weight: 700;">KyberChat</h2>
        <p style="font-size: 13px; color: rgba(255,255,255,0.8); margin: 5px 0 0 0;">Quantum-Safe Messaging</p>
      </div>
      <p>사용자 이름을 입력해주세요</p>
      <input type="text" id="usernameInput" placeholder="사용자 이름" maxlength="20">
      <div class="modal-buttons">
        <button id="joinButton">입장하기</button>
      </div>
    </div>
  </div>

  <!-- 비밀번호 입력 모달 -->
  <div id="passwordModal">
    <div class="password-box">
      <div class="password-icon">🔐</div>
      <div class="password-title">화면 복호화</div>
      <div class="password-description">암호화된 메시지를 보려면<br>비밀번호를 입력하세요</div>
      <input type="password" id="passwordInput" placeholder="비밀번호 입력" maxlength="20">
      <div class="password-buttons">
        <button id="decryptButton">복호화</button>
        <button id="cancelButton">취소</button>
      </div>
    </div>
  </div>

  <!-- 비밀번호 설정 모달 -->
  <div id="passwordSetupModal" style="display: none;">
    <div class="password-box">
      <div class="password-icon">🔑</div>
      <div class="password-title">비밀번호 설정</div>
      <div class="password-description">화면 암호화에 사용할<br>비밀번호를 설정하세요<br><small style="color: #999;">4자 이상 20자 이하</small></div>
      <input type="password" id="newPasswordInput" placeholder="새 비밀번호 입력" maxlength="20">
      <input type="password" id="confirmPasswordInput" placeholder="비밀번호 확인" maxlength="20">
      <div class="password-buttons">
        <button id="setPasswordButton">설정하기</button>
        <button id="cancelSetupButton">취소</button>
      </div>
    </div>
  </div>

  <div class="chat-container" id="chatContainer" style="display: none;">
    <div class="chat-header">
      <div style="display: flex; align-items: center; gap: 12px;">
        <svg width="36" height="36" viewBox="0 0 100 100">
          <defs>
            <linearGradient id="headerGrad" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" style="stop-color:#ffffff"/>
              <stop offset="100%" style="stop-color:#f0f0f0"/>
            </linearGradient>
          </defs>
          <circle cx="50" cy="50" r="45" fill="url(#headerGrad)" opacity="0.3"/>
          <path d="M50 25 L35 35 L35 50 Q35 65 50 70 Q65 65 65 50 L65 35 Z" fill="white"/>
          <circle cx="50" cy="52" r="5" fill="rgba(255,255,255,0.5)"/>
          <rect x="48" y="55" width="4" height="8" fill="rgba(255,255,255,0.5)"/>
        </svg>
        <h3 style="margin: 0; font-weight: 600;">KyberChat</h3>
      </div>
      <div class="user-info">
        <span id="currentUsername"></span>
        <button id="changeUsernameButton">이름 변경</button>
        <button id="passwordSetupButton" style="background: #28a745; color: white; margin-left: 8px;">비밀번호 설정</button>
        <button id="clearHistoryButton" style="background: #ff6b6b; color: white; margin-left: 8px;">기록 삭제</button>
      </div>
    </div>
    <div class="messages-container" id="messages"></div>
    <div class="message-input-container">
      <input type="text" id="messageInput" placeholder="메시지를 입력하세요...">
      <button id="sendButton">▲</button>
    </div>
  </div>

  <script src="kyber.js"></script>
  <script>
    // DOM 요소들
    const messagesDiv = document.getElementById('messages');
    const messageInput = document.getElementById('messageInput');
    const sendButton = document.getElementById('sendButton');
    const usernameModal = document.getElementById('usernameModal');
    const chatContainer = document.getElementById('chatContainer');
    const usernameInput = document.getElementById('usernameInput');
    const joinButton = document.getElementById('joinButton');
    const currentUsernameSpan = document.getElementById('currentUsername');
    const changeUsernameButton = document.getElementById('changeUsernameButton');
    const passwordModal = document.getElementById('passwordModal');
    const passwordInput = document.getElementById('passwordInput');
    const decryptButton = document.getElementById('decryptButton');
    const cancelButton = document.getElementById('cancelButton');
    
    const wsProtocol = location.protocol === 'https:' ? 'wss' : 'ws';
    let ws = null;
    let currentUsername = '';
    let isConnected = false;

    // Kyber 키 관리
    let myKyber = { publicKey: null, secretKey: null };
    let peerPublicKey = null;
    let isKeyExchangeComplete = false;

    // 전체 화면 암호화 상태
    let isScreenEncrypted = false;
    let originalMessages = new Map();
    let autoEncryptTimer = null;

    // 로컬 저장소 관리
    const CHAT_STORAGE_KEY = 'kyberchat_encrypted_messages';
    const STORAGE_PASSWORD = '1234'; // 기본 비밀번호
    const KYBER_STORAGE_KEY = 'kyberchat_kyber_messages'; // Kyber 키로 암호화된 메시지
    const PASSWORD_STORAGE_KEY = 'kyberchat_user_password'; // 사용자 비밀번호 저장

    // ===== 로컬 저장소 암호화/복호화 =====
    function simpleEncrypt(text, password) {
      const textBytes = new TextEncoder().encode(text);
      const passwordBytes = new TextEncoder().encode(password);
      const encrypted = new Uint8Array(textBytes.length);
      
      for (let i = 0; i < textBytes.length; i++) {
        encrypted[i] = textBytes[i] ^ passwordBytes[i % passwordBytes.length];
      }
      
      return btoa(String.fromCharCode(...encrypted));
    }

    function simpleDecrypt(encryptedText, password) {
      try {
        const encrypted = new Uint8Array(atob(encryptedText).split('').map(c => c.charCodeAt(0)));
        const passwordBytes = new TextEncoder().encode(password);
        const decrypted = new Uint8Array(encrypted.length);
        
        for (let i = 0; i < encrypted.length; i++) {
          decrypted[i] = encrypted[i] ^ passwordBytes[i % passwordBytes.length];
        }
        
        return new TextDecoder().decode(decrypted);
      } catch (error) {
        console.error('복호화 실패:', error);
        return null;
      }
    }

    function saveChatMessage(message, username, isSender, timestamp) {
      try {
        console.log('saveChatMessage 호출됨:', username, message.substring(0, 20) + '...');
        
        const chatData = {
          message: message,
          username: username,
          isSender: isSender,
          timestamp: timestamp || Date.now()
        };
        
        const existingData = localStorage.getItem(CHAT_STORAGE_KEY);
        console.log('기존 저장된 데이터:', existingData ? '있음' : '없음');
        
        let messages = [];
        if (existingData) {
          try {
            const decryptedData = simpleDecrypt(existingData, getUserPassword());
            if (decryptedData) {
              messages = JSON.parse(decryptedData);
              console.log('기존 메시지 복원:', messages.length + '개');
            } else {
              // 기본 비밀번호로 재시도
              const fallbackDecrypted = simpleDecrypt(existingData, STORAGE_PASSWORD);
              if (fallbackDecrypted) {
                messages = JSON.parse(fallbackDecrypted);
                console.log('기본 비밀번호로 기존 메시지 복원:', messages.length + '개');
              }
            }
          } catch (e) {
            console.log('기존 데이터 복호화 실패, 새로 시작');
          }
        }
        
        messages.push(chatData);
        console.log('새 메시지 추가 후 총 개수:', messages.length + '개');
        
        // 최대 1000개 메시지만 저장 (메모리 절약)
        if (messages.length > 1000) {
          messages = messages.slice(-1000);
          console.log('메시지 개수 제한 적용:', messages.length + '개');
        }
        
        const encryptedMessages = simpleEncrypt(JSON.stringify(messages), getUserPassword());
        localStorage.setItem(CHAT_STORAGE_KEY, encryptedMessages);
        
        console.log('메시지 저장 완료:', username, message.substring(0, 20) + '...');
        console.log('localStorage 확인:', localStorage.getItem(CHAT_STORAGE_KEY) ? '저장됨' : '저장 실패');
      } catch (error) {
        console.error('메시지 저장 실패:', error);
      }
    }

    function loadChatMessages() {
      try {
        console.log('loadChatMessages 호출됨');
        const encryptedData = localStorage.getItem(CHAT_STORAGE_KEY);
        console.log('localStorage에서 가져온 데이터:', encryptedData ? '있음' : '없음');
        
        if (!encryptedData) {
          console.log('저장된 데이터가 없습니다');
          return [];
        }
        
        const currentPassword = getUserPassword();
        console.log('사용 중인 비밀번호:', currentPassword);
        
        const decryptedData = simpleDecrypt(encryptedData, currentPassword);
        console.log('복호화 결과:', decryptedData ? '성공' : '실패');
        
        if (!decryptedData) {
          console.log('복호화 실패, 기본 비밀번호로 재시도');
          const fallbackDecrypted = simpleDecrypt(encryptedData, STORAGE_PASSWORD);
          if (fallbackDecrypted) {
            const messages = JSON.parse(fallbackDecrypted);
            console.log('기본 비밀번호로 복원 성공:', messages.length + '개');
            return messages;
          }
          return [];
        }
        
        const messages = JSON.parse(decryptedData);
        console.log('저장된 메시지 로드 성공:', messages.length + '개');
        return messages;
      } catch (error) {
        console.error('메시지 로드 실패:', error);
        return [];
      }
    }

    function clearChatMessages() {
      try {
        localStorage.removeItem(CHAT_STORAGE_KEY);
        localStorage.removeItem(KYBER_STORAGE_KEY);
        console.log('저장된 메시지 삭제 완료');
      } catch (error) {
        console.error('메시지 삭제 실패:', error);
      }
    }

    // ===== 비밀번호 관리 =====
    function getUserPassword() {
      return localStorage.getItem(PASSWORD_STORAGE_KEY) || STORAGE_PASSWORD;
    }

    function setUserPassword(password) {
      localStorage.setItem(PASSWORD_STORAGE_KEY, password);
      console.log('비밀번호가 설정되었습니다');
    }

    function clearUserPassword() {
      localStorage.removeItem(PASSWORD_STORAGE_KEY);
      console.log('비밀번호가 삭제되었습니다');
    }

    // ===== Kyber 키 기반 메시지 암호화/복호화 =====
    async function encryptMessageWithKyber(message, peerPublicKey) {
      try {
        if (!peerPublicKey || !myKyber.secretKey) {
          console.warn('Kyber 키가 준비되지 않음, 사용자 비밀번호로 암호화');
          return simpleEncrypt(message, getUserPassword());
        }
        
        // Kyber로 메시지 암호화
        const encryptedData = await Kyber.encrypt(peerPublicKey, message);
        return bytesToBase64(encryptedData);
      } catch (error) {
        console.error('Kyber 암호화 실패:', error);
        // 실패시 사용자 비밀번호로 암호화
        return simpleEncrypt(message, getUserPassword());
      }
    }

    async function decryptMessageWithKyber(encryptedMessage, mySecretKey) {
      try {
        if (!mySecretKey) {
          console.warn('Kyber 비밀키가 없음, 사용자 비밀번호로 복호화 시도');
          return simpleDecrypt(encryptedMessage, getUserPassword());
        }
        
        // Kyber로 메시지 복호화
        const encryptedData = base64ToBytes(encryptedMessage);
        const decryptedMessage = await Kyber.decrypt(encryptedData, mySecretKey);
        return decryptedMessage;
      } catch (error) {
        console.error('Kyber 복호화 실패:', error);
        // 실패시 사용자 비밀번호로 복호화
        return simpleDecrypt(encryptedMessage, getUserPassword());
      }
    }

    async function saveChatMessageWithKyber(message, username, isSender, timestamp) {
      try {
        const chatData = {
          message: message,
          username: username,
          isSender: isSender,
          timestamp: timestamp || Date.now()
        };
        
        // Kyber 키로 암호화 (실패시 사용자 비밀번호 사용)
        const encryptedData = await encryptMessageWithKyber(JSON.stringify(chatData), peerPublicKey);
        const existingData = localStorage.getItem(KYBER_STORAGE_KEY);
        let messages = [];
        
        // 기존 데이터 복호화
        if (existingData) {
          const decryptedData = await decryptMessageWithKyber(existingData, myKyber.secretKey);
          if (decryptedData) {
            messages = JSON.parse(decryptedData);
          }
        }
        
        messages.push(chatData);
        
        // 최대 1000개 메시지만 저장 (메모리 절약)
        if (messages.length > 1000) {
          messages = messages.slice(-1000);
        }
        
        // 전체 메시지 배열을 다시 암호화
        const encryptedMessages = await encryptMessageWithKyber(JSON.stringify(messages), peerPublicKey);
        localStorage.setItem(KYBER_STORAGE_KEY, encryptedMessages);
        
        console.log('메시지 저장 완료 (Kyber):', username, message.substring(0, 20) + '...');
      } catch (error) {
        console.error('메시지 저장 실패:', error);
      }
    }

    async function loadChatMessagesWithKyber() {
      try {
        const encryptedData = localStorage.getItem(KYBER_STORAGE_KEY);
        if (!encryptedData) return [];
        
        const decryptedData = await decryptMessageWithKyber(encryptedData, myKyber.secretKey);
        if (!decryptedData) return [];
        
        const messages = JSON.parse(decryptedData);
        console.log('저장된 메시지 로드 (Kyber):', messages.length + '개');
        return messages;
      } catch (error) {
        console.error('메시지 로드 실패:', error);
        return [];
      }
    }

    // ===== 사용자 이름 관리 =====
    function saveUsername(username) {
      localStorage.setItem('chatUsername', username);
    }

    function loadUsername() {
      return localStorage.getItem('chatUsername') || '';
    }

    async function connectToChat(username) {
      currentUsername = username;
      currentUsernameSpan.textContent = currentUsername;
      saveUsername(username);
      usernameModal.style.display = 'none';
      chatContainer.style.display = 'flex';
      
      // 먼저 Kyber 모듈 로드
      displaySystemMessage('Kyber 모듈 로딩 중...');
      try {
        await Kyber.ready();
        displaySystemMessage('Kyber 모듈 로드 완료');
      } catch (error) {
        console.error('Kyber 모듈 로드 실패:', error);
        displaySystemMessage('Kyber 모듈 로드 실패. 새로고침 해주세요.');
        return;
      }
      
      // WebSocket 연결
      displaySystemMessage('서버 연결 중...');
               // Render.com 배포용 WebSocket 연결
               ws = new WebSocket(`${wsProtocol}://${location.host}`);
      setupWebSocketHandlers();
    }

    // ===== WebSocket 핸들러 =====
    function setupWebSocketHandlers() {
      ws.addEventListener('open', () => {
        isConnected = true;
        displaySystemMessage('서버 연결 완료! 키 생성 중...');
        messageInput.disabled = true;
        
        // 키 생성 (지연 없이 즉시 실행)
        generateKyber().catch((error) => {
          console.error('키 생성 오류:', error);
          displaySystemMessage('키 생성 실패: ' + error.message);
        });
      });

      ws.addEventListener('message', async (event) => {
        try {
          const msg = JSON.parse(event.data);
          console.log('메시지 수신:', msg.type);
          
          // 공개키 수신
          if (msg.type === 'pubkey' && msg.key) {
            console.log('상대방 공개키 수신, 길이:', msg.key.length);
            peerPublicKey = base64ToBytes(msg.key);
            console.log('peerPublicKey 설정됨, 바이트 길이:', peerPublicKey.length);
            
            // 내 키도 준비되었는지 확인
            if (myKyber.publicKey && myKyber.secretKey) {
              isKeyExchangeComplete = true;
              displaySystemMessage('키 교환 완료!');
              messageInput.disabled = false;
              messageInput.placeholder = '메시지를 입력하세요...';
              console.log('키 교환 완료! 메시지 입력 가능');
              
              // 키 교환 완료 후 저장된 메시지 복원
              setTimeout(() => {
                console.log('키 교환 완료 후 메시지 복원 시도');
                restoreChatHistory();
              }, 1000);
            } else {
              displaySystemMessage('상대방 공개키 수신. 내 키 생성 중...');
              console.log('내 키가 아직 준비되지 않음. 대기 중...');
            }
            return;
          }
          
          // 암호화된 메시지 수신
          if (msg.type === 'encrypted_message' && msg.encryptedContent) {
            try {
              const encryptedData = base64ToBytes(msg.encryptedContent);
              const decryptedMessage = await Kyber.decrypt(encryptedData, myKyber.secretKey);
              displayMessage(decryptedMessage, false, msg.username || '알 수 없음', true);
            } catch (error) {
              displaySystemMessage('복호화 실패: ' + error.message);
            }
            return;
          }
          
          // 평문 메시지
          if (msg.content) {
            displayMessage(msg.content, false, msg.username || '알 수 없음', true);
          }
        } catch (error) {
          // JSON 아님 - 평문으로 처리
          if (event.data.length > 2) {
            displayMessage(event.data, false, '알 수 없음', true);
          }
        }
      });

      ws.addEventListener('close', () => {
        isConnected = false;
        displaySystemMessage('연결이 끊어졌습니다.');
        console.log('WebSocket 연결 종료');
      });

      ws.addEventListener('error', (error) => {
        console.error('WebSocket 오류:', error);
        displaySystemMessage('연결 오류 발생');
      });
    }

    // ===== Kyber 관련 함수 =====
    function bytesToBase64(bytes) {
      return btoa(String.fromCharCode(...new Uint8Array(bytes)));
    }

    function base64ToBytes(b64) {
      const bin = atob(b64);
      const bytes = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
      return bytes;
    }

    async function generateKyber() {
      // Kyber.ready()는 이미 connectToChat()에서 호출됨
      const { publicKey, secretKey } = await Kyber.keypair();
      myKyber.publicKey = publicKey;
      myKyber.secretKey = secretKey;
      console.log('내 키 생성 완료. publicKey 길이:', publicKey.length, 'secretKey 길이:', secretKey.length);
      
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ 
          type: 'pubkey', 
          alg: 'KYBER512', 
          key: bytesToBase64(publicKey) 
        }));
        console.log('내 공개키 전송 완료');
        displaySystemMessage('공개키 전송 완료. 상대방 대기 중...');
      }
      
      // 상대방 공개키가 이미 도착했는지 확인
      if (peerPublicKey && peerPublicKey.length > 0) {
        isKeyExchangeComplete = true;
        displaySystemMessage('키 교환 완료!');
        messageInput.disabled = false;
        messageInput.placeholder = '메시지를 입력하세요...';
        console.log('키 교환 완료! (상대방 키 이미 수신됨)');
        
        // 키 교환 완료 후 저장된 메시지 복원
        setTimeout(() => {
          console.log('키 교환 완료 후 메시지 복원 시도 (상대방 키 이미 수신됨)');
          restoreChatHistory();
        }, 1000);
      }
    }

    // ===== 메시지 전송 =====
    sendButton.addEventListener('click', async () => {
      const message = messageInput.value.trim();
      if (!message || !isKeyExchangeComplete) return;
      
      try {
        // 암호화
        const encryptedData = await Kyber.encrypt(peerPublicKey, message);
        const encryptedBase64 = bytesToBase64(encryptedData);
        
        // 전송
        ws.send(JSON.stringify({ 
          type: 'encrypted_message', 
          username: currentUsername,
          encryptedContent: encryptedBase64
        }));
        
        // 표시
        displayMessage(message, true, currentUsername, true);
        messageInput.value = '';
      } catch (error) {
        displaySystemMessage('전송 실패: ' + error.message);
      }
    });

    messageInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendButton.click();
    });

    // ===== 암호화된 메시지 표시 =====
    function displayMessageEncrypted(message, isSender = false, username = '') {
      console.log('[displayMessageEncrypted] 호출됨');
      
      const messageContainer = document.createElement('div');
      const messageElement = document.createElement('div');
      
      // 사용자 이름
      if (username && username !== '알 수 없음') {
        const usernameElement = document.createElement('div');
        usernameElement.textContent = username;
        usernameElement.classList.add('message-username');
        messageContainer.appendChild(usernameElement);
      }
      
      messageContainer.classList.add('message-container');
      
      if (isSender) {
        messageContainer.classList.add('sender-message-container');
        messageElement.classList.add('message-bubble', 'sender-message-bubble');
      } else {
        messageElement.classList.add('message-bubble');
      }
      
      // 암호화된 상태로 표시
      const encryptedText = '🔐 ' + generateRandomHex(32) + '...';
      messageElement.textContent = encryptedText;
      messageElement.style.fontFamily = 'monospace';
      messageElement.style.fontSize = '12px';
      messageElement.style.color = '#666';
      
      // 원본 메시지 저장
      originalMessages.set(messageElement, message);
      
      messageContainer.appendChild(messageElement);
      messagesDiv.appendChild(messageContainer);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
      
      // 화면이 암호화된 상태임을 표시
      isScreenEncrypted = true;
      
      console.log('[displayMessageEncrypted] 암호화된 메시지 표시 완료');
    }

    // ===== 메시지 표시 =====
    function displayMessage(message, isSender = false, username = '', saveToStorage = true) {
      console.log('[displayMessage] 호출됨. isScreenEncrypted:', isScreenEncrypted);
      
      const messageContainer = document.createElement('div');
      const messageElement = document.createElement('div');
      
      // 사용자 이름
      if (username && username !== '알 수 없음') {
        const usernameElement = document.createElement('div');
        usernameElement.textContent = username;
        usernameElement.classList.add('message-username');
        messageContainer.appendChild(usernameElement);
      }
      
      messageContainer.classList.add('message-container');
      
      if (isSender) {
        messageContainer.classList.add('sender-message-container');
        messageElement.classList.add('message-bubble', 'sender-message-bubble');
      } else {
        messageElement.classList.add('message-bubble');
      }
      
      // 항상 평문으로 표시 (암호화 상태와 무관)
      messageElement.textContent = message;
      originalMessages.set(messageElement, message);
      
      messageContainer.appendChild(messageElement);
      messagesDiv.appendChild(messageContainer);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
      
      // 메시지를 로컬 저장소에 Kyber 키로 암호화해서 저장
      if (saveToStorage && message && !message.startsWith('🔐')) {
        // 즉시 저장 (Kyber 키가 없어도 사용자 비밀번호로 저장)
        saveChatMessageWithKyber(message, username, isSender);
        // 추가로 기본 방식으로도 저장 (이중 백업)
        saveChatMessage(message, username, isSender);
      }
      
      // 화면이 암호화되어 있으면 암호화 상태를 해제하고 타이머 재시작
      if (isScreenEncrypted) {
        console.log('[displayMessage] 화면이 암호화됨. 상태 해제하고 타이머 재시작');
        isScreenEncrypted = false;
      }
      
      // 기존 타이머를 취소하고 새로 시작
      if (autoEncryptTimer) {
        console.log('[displayMessage] 기존 타이머 취소');
        clearTimeout(autoEncryptTimer);
      }
      
      // 10초 후 전체 암호화 (복원된 메시지가 아닌 경우에만)
      if (saveToStorage) {
        console.log('[displayMessage] 10초 타이머 시작');
        startAutoEncryptTimer();
      }
    }

    // 시스템 메시지 요소 (재사용)
    let systemMessageElement = null;
    let systemMessageTimer = null;

    function displaySystemMessage(message) {
      // 기존 타이머 취소
      if (systemMessageTimer) {
        clearTimeout(systemMessageTimer);
      }
      
      // 기존 시스템 메시지가 없으면 생성
      if (!systemMessageElement) {
        systemMessageElement = document.createElement('div');
        systemMessageElement.style.textAlign = 'center';
        systemMessageElement.style.color = '#999';
        systemMessageElement.style.fontSize = '12px';
        systemMessageElement.style.margin = '10px 0';
        systemMessageElement.style.transition = 'opacity 0.3s';
        messagesDiv.appendChild(systemMessageElement);
      }
      
      // 메시지 업데이트
      systemMessageElement.textContent = `🔐 ${message}`;
      systemMessageElement.style.opacity = '1';
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
      
      // 3초 후 페이드아웃 후 제거
      systemMessageTimer = setTimeout(() => {
        if (systemMessageElement) {
          systemMessageElement.style.opacity = '0';
          setTimeout(() => {
            if (systemMessageElement && systemMessageElement.parentNode) {
              systemMessageElement.parentNode.removeChild(systemMessageElement);
              systemMessageElement = null;
            }
          }, 300);
        }
      }, 3000);
    }

    // ===== 전체 화면 암호화/복호화 =====
    function generateRandomHex(length) {
      const chars = '0123456789abcdef';
      let result = '';
      for (let i = 0; i < length; i++) {
        result += chars[Math.floor(Math.random() * chars.length)];
      }
      return result;
    }

    function encryptAllMessages() {
      console.log('[encryptAllMessages] 호출됨. isScreenEncrypted:', isScreenEncrypted);
      if (isScreenEncrypted) {
        console.log('[encryptAllMessages] 이미 암호화됨. 종료');
        return;
      }
      
      // 타이머 정리
      if (autoEncryptTimer) {
        clearTimeout(autoEncryptTimer);
        autoEncryptTimer = null;
      }
      
      // originalMessages.clear()를 제거하여 기존 메시지 유지
      const messageElements = document.querySelectorAll('.message-bubble');
      console.log('[encryptAllMessages] 암호화할 메시지 수:', messageElements.length);
      
      messageElements.forEach((el) => {
        const text = el.textContent;
        if (!text.startsWith('🔐')) {
          // 아직 originalMessages에 없으면 저장
          if (!originalMessages.has(el)) {
            originalMessages.set(el, text);
          }
          el.textContent = '🔐 ' + generateRandomHex(32) + '...';
          el.style.fontFamily = 'monospace';
          el.style.fontSize = '12px';
          el.style.color = '#666';
        }
      });
      
      isScreenEncrypted = true;
      console.log('[encryptAllMessages] 암호화 완료. isScreenEncrypted:', isScreenEncrypted);
    }

    function decryptAllMessages() {
      console.log('[decryptAllMessages] 호출됨. isScreenEncrypted:', isScreenEncrypted);
      if (!isScreenEncrypted) {
        console.log('[decryptAllMessages] 암호화 안됨. 종료');
        return;
      }
      
      const messageElements = document.querySelectorAll('.message-bubble');
      console.log('[decryptAllMessages] 복호화할 메시지 수:', messageElements.length);
      
      messageElements.forEach((el) => {
        if (el.textContent.startsWith('🔐')) {
          const original = originalMessages.get(el);
          if (original) {
            el.textContent = original;
            el.style.fontFamily = '';
            el.style.fontSize = '';
            el.style.color = '';
          }
        }
      });
      
      isScreenEncrypted = false;
      console.log('[decryptAllMessages] 복호화 완료. isScreenEncrypted:', isScreenEncrypted);
      
      // 복호화 후 10초 뒤 다시 암호화
      console.log('[decryptAllMessages] 10초 타이머 시작');
      startAutoEncryptTimer();
    }

    function startAutoEncryptTimer() {
      console.log('[startAutoEncryptTimer] 호출됨');
      if (autoEncryptTimer) {
        console.log('[startAutoEncryptTimer] 기존 타이머 취소');
        clearTimeout(autoEncryptTimer);
      }
      
      autoEncryptTimer = setTimeout(() => {
        console.log('[startAutoEncryptTimer] 10초 경과. isScreenEncrypted:', isScreenEncrypted);
        if (!isScreenEncrypted) {
          encryptAllMessages();
        } else {
          console.log('[startAutoEncryptTimer] 이미 암호화됨. 스킵');
        }
      }, 10000);
      console.log('[startAutoEncryptTimer] 타이머 설정 완료');
    }

    // ===== 이벤트 리스너 =====
    // 암호화된 화면 클릭 시 비밀번호 모달
    document.addEventListener('click', (event) => {
      if (passwordModal.style.display === 'flex') return;
      
      if ((event.target.closest('.messages-container') || event.target.closest('.message-bubble')) && isScreenEncrypted) {
        passwordModal.style.display = 'flex';
        passwordInput.focus();
      }
    });

    // 복호화 버튼
    decryptButton.addEventListener('click', () => {
      if (passwordInput.value === getUserPassword()) {
        decryptAllMessages();
        passwordModal.style.display = 'none';
        passwordInput.value = '';
      } else {
        alert('비밀번호가 틀렸습니다.');
        passwordInput.value = '';
        passwordInput.focus();
      }
    });

    // 취소 버튼
    cancelButton.addEventListener('click', () => {
      passwordModal.style.display = 'none';
      passwordInput.value = '';
    });

    // Enter 키
    passwordInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') decryptButton.click();
    });

    // ESC 키
    passwordInput.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') cancelButton.click();
    });

    // ===== 사용자 이름 입력 =====
    joinButton.addEventListener('click', () => {
      const username = usernameInput.value.trim();
      if (username.length < 2) {
        alert('사용자 이름은 2자 이상이어야 합니다.');
        return;
      }
      connectToChat(username);
    });

    usernameInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') joinButton.click();
    });

    changeUsernameButton.addEventListener('click', () => {
      if (confirm('이름을 변경하시겠습니까?')) {
        usernameModal.style.display = 'flex';
        chatContainer.style.display = 'none';
        usernameInput.value = currentUsername;
        usernameInput.select();
      }
    });

    // 기록 삭제 버튼
    const clearHistoryButton = document.getElementById('clearHistoryButton');
    clearHistoryButton.addEventListener('click', () => {
      if (confirm('모든 채팅 기록을 삭제하시겠습니까?\n이 작업은 되돌릴 수 없습니다.')) {
        clearChatMessages();
        messagesDiv.innerHTML = '';
        originalMessages.clear();
        displaySystemMessage('채팅 기록이 삭제되었습니다.');
      }
    });

    // 비밀번호 설정 버튼
    const passwordSetupButton = document.getElementById('passwordSetupButton');
    const passwordSetupModal = document.getElementById('passwordSetupModal');
    const newPasswordInput = document.getElementById('newPasswordInput');
    const confirmPasswordInput = document.getElementById('confirmPasswordInput');
    const setPasswordButton = document.getElementById('setPasswordButton');
    const cancelSetupButton = document.getElementById('cancelSetupButton');

    passwordSetupButton.addEventListener('click', () => {
      passwordSetupModal.style.display = 'flex';
      newPasswordInput.focus();
    });

    setPasswordButton.addEventListener('click', () => {
      const newPassword = newPasswordInput.value.trim();
      const confirmPassword = confirmPasswordInput.value.trim();

      if (newPassword.length < 4) {
        alert('비밀번호는 4자 이상이어야 합니다.');
        return;
      }

      if (newPassword !== confirmPassword) {
        alert('비밀번호가 일치하지 않습니다.');
        return;
      }

      setUserPassword(newPassword);
      passwordSetupModal.style.display = 'none';
      newPasswordInput.value = '';
      confirmPasswordInput.value = '';
      displaySystemMessage('비밀번호가 설정되었습니다.');
    });

    cancelSetupButton.addEventListener('click', () => {
      passwordSetupModal.style.display = 'none';
      newPasswordInput.value = '';
      confirmPasswordInput.value = '';
    });

    // 비밀번호 설정 모달에서 Enter 키 처리
    newPasswordInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') confirmPasswordInput.focus();
    });

    confirmPasswordInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') setPasswordButton.click();
    });

    // ===== 저장된 메시지 복원 =====
    async function restoreChatHistory() {
      try {
        console.log('=== 메시지 복원 시작 ===');
        console.log('현재 localStorage 상태:', localStorage.length + '개 항목');
        console.log('CHAT_STORAGE_KEY 값:', localStorage.getItem(CHAT_STORAGE_KEY) ? '있음' : '없음');
        console.log('KYBER_STORAGE_KEY 값:', localStorage.getItem(KYBER_STORAGE_KEY) ? '있음' : '없음');
        
        // 먼저 기본 암호화 방식으로 시도
        const savedMessages = loadChatMessages();
        if (savedMessages.length > 0) {
          console.log('저장된 채팅 기록 복원 중...', savedMessages.length + '개');
          
          // 기존 메시지 컨테이너 초기화
          messagesDiv.innerHTML = '';
          originalMessages.clear();
          
          // 저장된 메시지들을 암호화된 상태로 표시
          savedMessages.forEach((msg, index) => {
            console.log(`메시지 ${index + 1} 복원:`, msg.username, msg.message.substring(0, 20) + '...');
            displayMessageEncrypted(msg.message, msg.isSender, msg.username); // 암호화된 상태로 표시
          });
          
          // 복원 완료 메시지
          displaySystemMessage(`${savedMessages.length}개의 저장된 메시지를 복원했습니다. (암호화됨)`);
          console.log('=== 메시지 복원 완료 ===');
          return;
        }
        
        console.log('기본 방식으로 복원 실패, Kyber 방식 시도');
        
        // Kyber 키가 준비될 때까지 대기 후 시도
        let attempts = 0;
        while ((!myKyber.secretKey || !peerPublicKey) && attempts < 100) {
          await new Promise(resolve => setTimeout(resolve, 100));
          attempts++;
        }
        
        console.log('Kyber 키 상태:', {
          mySecretKey: myKyber.secretKey ? '있음' : '없음',
          peerPublicKey: peerPublicKey ? '있음' : '없음',
          attempts: attempts
        });
        
        if (myKyber.secretKey && peerPublicKey) {
          console.log('Kyber 키 준비됨, Kyber 암호화 방식으로 복원 시도');
          const kyberMessages = await loadChatMessagesWithKyber();
          if (kyberMessages.length > 0) {
            console.log('저장된 채팅 기록 복원 중 (Kyber)...', kyberMessages.length + '개');
            
            // 기존 메시지 컨테이너 초기화
            messagesDiv.innerHTML = '';
            originalMessages.clear();
            
            // 저장된 메시지들을 암호화된 상태로 표시
            kyberMessages.forEach((msg, index) => {
              console.log(`Kyber 메시지 ${index + 1} 복원:`, msg.username, msg.message.substring(0, 20) + '...');
              displayMessageEncrypted(msg.message, msg.isSender, msg.username); // 암호화된 상태로 표시
            });
            
            // 복원 완료 메시지
            displaySystemMessage(`${kyberMessages.length}개의 저장된 메시지를 복원했습니다. (Kyber 암호화됨)`);
            console.log('=== Kyber 메시지 복원 완료 ===');
          } else {
            console.log('Kyber 방식으로도 복원할 메시지가 없음');
          }
        } else {
          console.log('Kyber 키가 준비되지 않음, 복원 실패');
        }
      } catch (error) {
        console.error('메시지 복원 실패:', error);
      }
    }

    // ===== 캡처 방지 기능 =====
    function preventScreenshot() {
      // 개발자 도구 방지
      let devtools = {open: false, orientation: null};
      const threshold = 160;
      
      // 더 강력한 캡처 방지
      setInterval(() => {
        if (window.outerHeight - window.innerHeight > threshold || 
            window.outerWidth - window.innerWidth > threshold) {
          if (!devtools.open) {
            devtools.open = true;
            console.clear();
            console.log('%c캡처가 감지되었습니다!', 'color: red; font-size: 50px; font-weight: bold;');
            // 즉시 모든 메시지 암호화
            encryptAllMessages();
            // 페이지 내용을 완전히 숨김
            document.body.innerHTML = '<div style="background: black; color: white; padding: 50px; text-align: center; font-size: 24px;">🔒 캡처가 감지되어 화면이 차단되었습니다.<br>페이지를 새로고침하세요.</div>';
          }
        } else {
          devtools.open = false;
        }
      }, 100);
      
      // 키보드 단축키 방지
      document.addEventListener('keydown', (e) => {
        // F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U 등 방지
        if (e.key === 'F12' || 
            (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'J')) ||
            (e.ctrlKey && e.key === 'U') ||
            (e.ctrlKey && e.key === 'S') ||
            (e.ctrlKey && e.key === 'P')) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
      });
      
      // 마우스 우클릭 방지
      document.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        return false;
      });
      
      // 드래그 방지
      document.addEventListener('dragstart', (e) => {
        e.preventDefault();
        return false;
      });
      
      // 선택 방지
      document.addEventListener('selectstart', (e) => {
        e.preventDefault();
        return false;
      });
      
      // 화면 캡처 감지 (일부 브라우저에서 지원)
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          console.log('화면이 숨겨졌습니다 - 캡처 가능성');
          // 화면이 숨겨지면 내용을 암호화
          if (!isScreenEncrypted) {
            encryptAllMessages();
          }
        }
      });
      
      // 페이지 포커스 감지
      window.addEventListener('blur', () => {
        console.log('페이지 포커스 해제 - 캡처 가능성');
        // 포커스를 잃으면 내용을 암호화
        if (!isScreenEncrypted) {
          encryptAllMessages();
        }
      });
      
      window.addEventListener('focus', () => {
        console.log('페이지 포커스 복원');
      });
      
      // 모바일에서 뒤로가기 버튼 감지
      window.addEventListener('popstate', () => {
        console.log('뒤로가기 감지 - 캡처 가능성');
        if (!isScreenEncrypted) {
          encryptAllMessages();
        }
      });
      
      // 페이지 언로드 시 내용 암호화
      window.addEventListener('beforeunload', () => {
        if (!isScreenEncrypted) {
          encryptAllMessages();
        }
      });
      
      // 모바일 터치 이벤트 감지 (스크린샷 제스처)
      let touchStartY = 0;
      document.addEventListener('touchstart', (e) => {
        touchStartY = e.touches[0].clientY;
      });
      
      document.addEventListener('touchend', (e) => {
        const touchEndY = e.changedTouches[0].clientY;
        const deltaY = touchStartY - touchEndY;
        
        // 위로 스와이프 (스크린샷 제스처 가능성)
        if (deltaY > 100) {
          console.log('위로 스와이프 감지 - 스크린샷 가능성');
          if (!isScreenEncrypted) {
            encryptAllMessages();
          }
        }
      });
    }

    // ===== localStorage 디버깅 =====
    function debugLocalStorage() {
      console.log('=== localStorage 디버깅 ===');
      console.log('localStorage 총 항목 수:', localStorage.length);
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        console.log(`키 ${i}:`, key);
        if (key && key.includes('kyberchat')) {
          const value = localStorage.getItem(key);
          console.log(`값 길이:`, value ? value.length : 0);
        }
      }
      console.log('=== 디버깅 완료 ===');
    }

    // ===== 초기화 =====
    window.addEventListener('load', () => {
      console.log('=== 페이지 로드 시작 ===');
      
      // localStorage 디버깅
      debugLocalStorage();
      
      const savedUsername = loadUsername();
      if (savedUsername) {
        usernameInput.value = savedUsername;
        connectToChat(savedUsername);
      } else {
        usernameModal.style.display = 'flex';
      }
      
      // 페이지 로드 시 저장된 메시지 복원 (지연 실행)
      setTimeout(() => {
        console.log('페이지 로드 후 메시지 복원 시도');
        restoreChatHistory();
      }, 2000);
      
      // 캡처 방지 기능 활성화
      preventScreenshot();
    });
  </script>
</body>
</html>

